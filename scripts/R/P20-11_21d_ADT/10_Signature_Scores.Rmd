---
title: "10. P20-11 ADT (Only) treated (21 Days): Signature scores"
author: "Romuald Parmentier"
date: "2025-04-14"
output: html_document
---

# Prepare environment

```{r Libraries, fonctions, palettes, paths, message = F}

#Libraries
library(SingleCellExperiment)
library(Seurat)
library(ggplot2)
library(dplyr)
library(tidyr)
library(ggbeeswarm)
library(gridExtra)
library(scater)
library(org.Hs.eg.db)
library(ComplexHeatmap)
library(ggpubr)
library(AnnotationHub)
library(msigdbr)
library(clusterProfiler)
library(stringr)

# Functions and palettes
source("/scicore/home/wykopa75/GROUP/rparmentier/sc_RNAseq/Projects/Prostate/Xenograft_Models/Xenograft_Models_Custom_Functions.R")
source("/scicore/home/wykopa75/GROUP/rparmentier/sc_RNAseq/Projects/Prostate/Xenograft_Models/Xenograft_Models_Color_Palettes.R")

# Create output path
out_path = create_exp_folder(
  organ = "Prostate" ,
  project = "Xenograft_Models",
  samples_ID = "P20-11_21d_ADT",
  exp = "10_Signature_Scores"
)

```

############################################################################
############################################################################

# Prepare the data

```{r Load sce object after clustering}

# Load combined rescaled sce object after normalization and rescaling
file_path = get_exp_file_path(
  organ = "Prostate" ,
  project = "Xenograft_Models",
  samples_ID = "P20-11_21d_ADT",
  prev_exp = "7_Clustering",
  pattern = "sce_obj_clustered.rds")

sce_obj = readRDS(file_path)

```

```{r Convert sce to seurat}

seurat_obj = as.Seurat(
  x = sce_obj, 
  counts = "counts", 
  data = "logcounts"
)

# Set the originalexp (aka "RNA" as the default assay)
DefaultAssay(seurat_obj) = "originalexp"

# Adds scale.data slot
seurat_obj = ScaleData(seurat_obj)

```

############################################################################
############################################################################

# Prepare gene set list to calculate signature scores

```{r Load HALLMARK, GOBP, GOMF and C2 gene sets}

HALLMARK = read.gmt("/scicore/home/wykopa75/GROUP/rparmentier/sc_RNAseq/Projects/Sequencing_Data/Gene_sets/MSigDB_HALLMARKS_hs_v2023_2.gmt")
GOBP = read.gmt("/scicore/home/wykopa75/GROUP/rparmentier/sc_RNAseq/Projects/Sequencing_Data/Gene_sets/MSigDB_C5_GO_Biological_Process.gmt")
GOMF = read.gmt("/scicore/home/wykopa75/GROUP/rparmentier/sc_RNAseq/Projects/Sequencing_Data/Gene_sets/MSigDB_C5_GO_Molecular_Function.gmt")
C2 = read.gmt("/scicore/home/wykopa75/GROUP/rparmentier/sc_RNAseq/Projects/Sequencing_Data/Gene_sets/MSigDB_C2_Curated_Gensets.gmt")


list_collection = list(
  "C2" = C2, #BIOCARTA, KEGG_MEDICUS, PID, REACTOME, WIKIPATHWAY, KEGG_LEGACY
  "HALLMARK" = HALLMARK,
  "GOBP" = GOBP,
  "GOMF" = GOMF)

# Make a single df out of all gene sets fron differnet collecitons
gene_set_collection_df = data.table::rbindlist(list_collection)

```

```{r Pattern matching to select pathway of interst }

targetted_terms <- gene_set_collection_df %>% 
  filter(str_detect(term, pattern = "ANDROGEN|HALLMARK")) %>% 
  pull(term)

targetted_terms = unique(as.character(targetted_terms))

```

```{r Create signature with custom gene list}

custom_gene_sets_df = tibble()

# ALIMONTI senescence signature score
# (https://www.nature.com/articles/s41467-022-29824-1#Sec37)
############################################################

# Check presence and alias if needed
allias = sapply(c("P16", "P15", "P19", "P21", "P27" , "PAI-1"), function(gene){
  check_aliase(
    sce = sce_obj, 
    gene = gene )
}
)

gene_set_df = tibble(
  term = "ALIMONTI_SENESCENCE",
  gene = allias
)

# Add the custom pahway to a df
custom_gene_sets_df = bind_rows(custom_gene_sets_df, gene_set_df)

```

```{r Load NE gene sets retrieved from litterature}

custom_gene_sets_NE = read.csv2(
  "/scicore/home/wykopa75/GROUP/rparmentier/sc_RNAseq/Projects/Prostate/Xenograft_Models/Xenograft_Custom_Gene_Sets.csv",
  header = T)

custom_gene_sets_df = bind_rows(custom_gene_sets_df, custom_gene_sets_NE)

```

```{r Assemble gene sets of choice to test signature}

# Gater all selected gene terms from MsigDB
MSigDB_terms = c(targetted_terms)

# Select gene set to score withing the MsigDB collection df
gene_sets_to_score_df = gene_set_collection_df %>%
  filter(term %in% MSigDB_terms)

# Add custom pathway to the term to score df
gene_sets_to_score_df = bind_rows(gene_sets_to_score_df, custom_gene_sets_df)

print(paste0(length(unique(gene_sets_to_score_df$term)), " pathways to score"))

```

# Add signature scores to SCE

```{r Add signature score to sce object }

terms_col_idx = str_detect(string = colnames(colData(sce_obj)), pattern = "score")
already_score_terms = str_remove(string = colnames(colData(sce_obj))[terms_col_idx],pattern = "_score")
terms_to_score_names = setdiff(unique(gene_sets_to_score_df$term), already_score_terms )

# Select only gene sets that havn't been scored yet
gene_sets_to_score_df = gene_sets_to_score_df %>%
  filter(term %in% terms_to_score_names )

for(pathway in unique(gene_sets_to_score_df$term)){
  
  print(paste0("Adding signature score to sce: ", pathway))
  
  # Select genes on which calculating the signature score
  genes_of_interest <- gene_sets_to_score_df %>% filter(term == pathway)
  genes_of_interest = as.vector(genes_of_interest$gene)
  
  # Calculate signature score and add it to seurat object as an alternative assays (signature only + signature genes only)
  seurat_obj = calculate_signature_score(
    assay_name = "originalexp",
    seurat_object = seurat_obj, 
    signature_name = pathway, 
    signature_genes = genes_of_interest
  )
  
  # Transfer the signature score from seurat to sce (score in colData, genes of the signature marked in the rowData)
  sce_obj = add_signature_score_to_sce(
    sce_object = sce_obj,
    seurat_object = seurat_obj,
    signature_name = pathway,
    seurat_assay = paste0(pathway, "_score_only"),
    signature_genes = genes_of_interest
  )
  
}

```

```{r Export scored sce object}

saveRDS(
  object = sce_obj,
  file = paste0(out_path, time_stamp(),"sce_obj_scored.rds")
)

```

# Visualize signature scores

```{r Reload sce object if needed}

file_path = get_exp_file_path(
  organ = "Prostate" ,
  project = "Xenograft_Models",
  samples_ID = "P20-11_21d_ADT",
  prev_exp = "10_Signature_Scores",
  pattern = "sce_obj_scored.rds")

sce_obj = readRDS(file_path)

# Export all metadata into a dataframe
md = colData(sce_obj)
md = as_tibble(md)

```

## Violin plots — DHT vs no DHT

```{r Check normal distribution of scores}

## Stat test
######

# Test with Shapiro
# Potential outliers from noDHT conditions is interferring 
shapiro_df = md %>%
  group_by(Multiplexing_Condition) %>%
  rstatix::shapiro_test(HALLMARK_ANDROGEN_RESPONSE_score)

# Test with Kolmogorov-Smirnov
# Looks normally distributed in both condition
ks.test(x = scale(md$HALLMARK_ANDROGEN_RESPONSE_score[which(md$Multiplexing_Condition == "DHT_noENZA")]), y = "pnorm")
ks.test(x = scale(md$HALLMARK_ANDROGEN_RESPONSE_score[which(md$Multiplexing_Condition == "noDHT_noENZA")]), "pnorm",)

# Check normality with Q-Q plots
#################################

# Q-Q plot seems to confirm normal distribution 

ggplot(md, aes(sample = HALLMARK_ANDROGEN_RESPONSE_score)) +
  stat_qq() +
  stat_qq_line() +
  theme_minimal() +
  labs(
    title = "Q-Q Plot of signature score",
    x = "Theoretical Quantiles (Normal distribution)",
    y = "Sample Quantiles (Androgen Response score)"
  )

ggpubr::ggqqplot(data = md, x = "HALLMARK_ANDROGEN_RESPONSE_score", facet.by = "Multiplexing_Condition", conf.int.level = 0.95)

```

```{r Violin plot: HALLMARK ANDROGEN RESPONSE (DHT vs -DHT)}

# t-test comparison
###################

#  y positions
y_max <- max(
  md$HALLMARK_ANDROGEN_RESPONSE_score[md$Multiplexing_Condition == "DHT_noENZA"],
  md$HALLMARK_ANDROGEN_RESPONSE_score[md$Multiplexing_Condition == "DHT_ENZA"]
) + 0.05

ttest_df <- md %>%
  rstatix::t_test(
    formula = HALLMARK_ANDROGEN_RESPONSE_score ~ Multiplexing_Condition,
    ref.group = "DHT_noENZA",
    var.equal = FALSE
  ) %>%
  mutate(y.position = y_max) %>%
  adjust_pvalue(method = "bonferroni") %>%   # or "fdr", "bonferroni", etc.
  add_significance("p.adj") %>%
  mutate(y.position = y_max)


###############
### Draw plot
############

plot <- ggplot(md) +
  geom_violin(
    aes(x = Multiplexing_Condition, y = .data[["HALLMARK_ANDROGEN_RESPONSE_score"]], fill = Multiplexing_Condition),
    alpha = 0.8,
    position = position_dodge(width = 0.8),
    scale = "width"
  ) +
  geom_boxplot(
    aes(x = Multiplexing_Condition, y = .data[["HALLMARK_ANDROGEN_RESPONSE_score"]], fill = Multiplexing_Condition),
    width = 0.1,
    position = position_dodge(width = 0.8),
    alpha = 0.5
  ) +
  stat_pvalue_manual(
    ttest_df,
    label = "p",
    y.position = "y.position",
    tip.length = 0.01,
    size = 3
  ) +
  geom_hline(
    yintercept = 0,
    linetype = "dotted",
    color = "black",
    size = 0.8
  ) +
  scale_fill_manual(values = pal.treatment) +
  labs(
    title = paste0("Signature score: ", "HALLMARK_ANDROGEN_RESPONSE_score"),
    x = "",
    y = ""  ) +
  guides(fill = "none") +
  theme_minimal() + 
  theme(
    axis.text.x = element_blank(),
    axis.title = element_text(size = 12),  # Customize axis title appearance
    axis.text = element_text(size = 10),    # Customize axis text appearance
    axis.line = element_line(size = 0.5),   # Customize axis line appearance
    axis.ticks = element_line(size = 0.5)) 

ggsave(
  plot = plot,
  filename = paste0(out_path,time_stamp(),"plot_Violins_HALLMARK_ANDROGEN_RESPONSE_Treatment.pdf"),
  device = "pdf",
  width = 7,
  height = 5)

```

```{r Violin plot: Day 3 and Day 21 on the same plot}

file_path = get_exp_file_path(
  organ = "Prostate" ,
  project = "Xenograft_Models",
  samples_ID = "P20-11_3d_ADT",
  prev_exp = "9_Signature_Scores",
  pattern = "sce_obj_scored.rds")

sce_obj_day3 = readRDS(file_path)

md_day3 = colData(sce_obj_day3)
md_day3 = as_tibble(md_day3)

md$Day = "Day_21"
md_day3$Day = "Day_3"


md_day21_day3 = bind_rows(
  md_day3[,c("Day","Multiplexing_Condition","HALLMARK_ANDROGEN_RESPONSE_score")],
  md[,c("Day","Multiplexing_Condition","HALLMARK_ANDROGEN_RESPONSE_score")]
  )

md_day21_day3$Day = factor(md_day21_day3$Day, levels = c("Day_3", "Day_21"))


plot <- ggplot(md_day21_day3) +
  geom_violin(
    aes(x = Multiplexing_Condition, y = HALLMARK_ANDROGEN_RESPONSE_score, fill = Multiplexing_Condition),
    alpha = 0.8,
    position = position_dodge(width = 0.8),
    scale = "width"
  ) +
  geom_boxplot(
    aes(x = Multiplexing_Condition, y = HALLMARK_ANDROGEN_RESPONSE_score, fill = Multiplexing_Condition),
    width = 0.1,
    position = position_dodge(width = 0.8),
    alpha = 0.5
  ) +
  scale_fill_manual(values = pal.treatment) +
  labs(
    title = paste0("Signature score: ", "HALLMARK_ANDROGEN_RESPONSE_score"),
    x = "",
    y = ""  ) +
  guides(fill = "none") +
  theme_minimal() + 
  theme(
    axis.text.x = element_blank(),
    axis.title = element_text(size = 12),  # Customize axis title appearance
    axis.text = element_text(size = 10),    # Customize axis text appearance
    axis.line = element_line(size = 0.5),   # Customize axis line appearance
    axis.ticks = element_line(size = 0.5)) +
  facet_wrap(~Day)

ggsave(
  plot = plot,
  filename = paste0(out_path,time_stamp(),"plot_Violins_HALLMARK_ANDROGEN_RESPONSE_Treatment_Day3_Day21.pdf"),
  device = "pdf",
  width = 7,
  height = 5)

```

```{r Violin plot: targeted gene list}

genes <- c("AR", "SOX2", "AZGP1")

# --- Build a long data.frame with expression per cell & gene -------------------
expr_mtx <- as.matrix(logcounts(sce_obj)[genes,])
cell_md  <- as_tibble(colData(sce_obj)) %>%
  mutate(.cell = colnames(sce_obj))

expr_df <- as_tibble(t(expr_mtx), rownames = ".cell") %>%
  left_join(cell_md, by = ".cell") %>%
  pivot_longer(cols = all_of(genes), names_to = "Gene", values_to = "Expression")

# ensure cluster is a factor (and order by natural sort)
expr_df$Multiplexing_Condition <- factor(
  expr_df$Multiplexing_Condition,
  levels = sort(unique(expr_df$Multiplexing_Condition))
)

# --- Plot: facets stacked (one per gene), colored by cluster palette -----------
p <- ggplot(expr_df, aes(x = Multiplexing_Condition, y = Expression, fill = Multiplexing_Condition)) +
  geom_violin(scale = "width", alpha = 0.6, trim = TRUE) +
  geom_boxplot(width = 0.12, alpha = 0.6, outlier.shape = NA) +
  facet_grid(rows = vars(Gene)) +  # stacked facets (one on top of the other)
  scale_fill_manual(values = pal.treatment) +  # uses your cluster palette defined earlier
  labs(x = "DHT condition", y = "log-normalized expression", fill = "none") +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    strip.text       = element_text(face = "bold", size = 12),
    axis.text.x      = element_text(angle = 45, hjust = 1, vjust = 1),
    legend.position  = "none"
  )

print(p)

# --- Optional: save to file ----------------------------------------------------
ggsave(
  plot = p,
  filename = paste0(out_path, time_stamp(), "facets_AR_SOX2_by_DHT_Condition.pdf"),
  device = "pdf",
  width = 5, height = 6
)


```

## Violin plots — across all clusters

```{r Violin plots for all signatures}

gene_signature_scores = colnames(md)[which(grepl(x = colnames(md), pattern = "_score"))]
pathway_id = 1

plot_list = list()

for(gene_signature in gene_signature_scores){
  
  #######
  ## Stat test
  ######
  
  # Build formula dynamically
  fml <- as.formula(paste(gene_signature, "~ louvain_pc20_k45_res0.6"))
  kruskal.test(formula = fml, data = md)
  
  dunn_results <- md %>%
    dunn_test(formula = fml, p.adjust.method = "bonferroni") %>%
    filter(group1 == "cluster_19" | group2 == "cluster_19")
  
  # Calculate y position of stars
  dunn_results <- dunn_results %>%
    rowwise() %>%
    mutate(
      y.position = 0.05 + max(md[[gene_signature]][md$walktrap_clust == group1 | md$walktrap_clust == group2]),
      cluster_ref = if_else(group1 == "cluster_19", group2, group1),
      xmin = cluster_ref,
      xmax = cluster_ref
    ) %>%
    ungroup()
  
  ###############
  ### Draw plot
  ############
  
  plot <- ggplot(md) +
    geom_violin(
      aes(x = louvain_pc20_k45_res0.6, y = .data[[gene_signature]], fill = louvain_pc20_k45_res0.6),
      alpha = 0.8,
      position = position_dodge(width = 0.8),
      scale = "width"
    ) +
    geom_boxplot(
      aes(x = louvain_pc20_k45_res0.6, y = .data[[gene_signature]], fill = louvain_pc20_k45_res0.6),
      width = 0.1,
      position = position_dodge(width = 0.8),
      alpha = 0.5
    ) +
    # stat_pvalue_manual(
    #   dunn_results,
    #   label = "p.adj.signif",
    #   y.position = "y.position",
    #   tip.length = 0.01,
    #   size = 3
    # ) +
    geom_hline(
      yintercept = 0,
      linetype = "dotted",
      color = "black",
      size = 0.8
    ) +
    scale_fill_manual(values = pal_clustering) +
    labs(
      title = paste0("Signature score: ", gene_signature),
      x = "Cluster",
      y = "Signature score",
      fill = "Cluster"
    ) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
      strip.text = element_text(size = 12),
      strip.background = element_rect(fill = "grey90", color = "grey40", linewidth = 0.5),
      panel.background = element_rect(fill = "transparent", color = NA),
      plot.background = element_rect(fill = "transparent", color = NA),
      panel.grid.major = element_line(color = "grey90"),
      panel.grid.minor = element_line(color = "grey95"),
      panel.border = element_rect(color = "grey60", fill = NA, linewidth = 0.5)
    )
  
  plot_list[[pathway_id]] = plot
  
  pathway_id = pathway_id + 1
  
}

multiple_page_layout <- gridExtra::marrangeGrob(
  grobs = plot_list, 
  nrow = 1, ncol = 1)

ggsave(
  plot = multiple_page_layout,
  filename = paste0(out_path,time_stamp(),"plot_Violins_Signatures_Clusters.pdf"),
  device = "pdf",
  width = 12,
  height = 8)

```

```{r Violin plot: HALLMARK ANDROGEN RESPONSE across clusters}

md$louvain_pc20_k45_res0.6 = factor(md$louvain_pc20_k45_res0.6, levels = rev(c(1,2,5,3,6,4)))

plot <- ggplot(md) +
  geom_violin(
    aes(x = HALLMARK_ANDROGEN_RESPONSE_score, y = louvain_pc20_k45_res0.6, fill = louvain_pc20_k45_res0.6),
    alpha = 0.8,
    position = position_dodge(width = 0.8),
    scale = "width"
  ) +
  geom_boxplot(
    aes(x = HALLMARK_ANDROGEN_RESPONSE_score, y = louvain_pc20_k45_res0.6, fill = louvain_pc20_k45_res0.6),
    width = 0.1,
    position = position_dodge(width = 0.8),
    alpha = 0.5
  ) +
  geom_hline(
    yintercept = 0,
    linetype = "dotted",
    color = "black",
    size = 0.8
  ) +
  scale_fill_manual(values = pal_clustering_bis) +
  labs(
    x = "Cluster",
    y = "Signature score",
    fill = "Cluster"
  ) +
  theme(
    axis.text.x = element_text(hjust = 1, size = 10),
    strip.text = element_text(size = 12),
    strip.background = element_rect(fill = "grey90", color = "grey40", linewidth = 0.5),
    panel.background = element_rect(fill = "transparent", color = NA),
    plot.background = element_rect(fill = "transparent", color = NA),
    panel.grid.major = element_line(color = "grey90"),
    panel.grid.minor = element_line(color = "grey95"),
    panel.border = element_rect(color = "grey60", fill = NA, linewidth = 0.5)
  ) +
  guides(fill = "none") +
  scale_x_continuous(
    limits = c(-0.1, 1),
    breaks = c(0, 0.25, 0.5, 0.75, 1)
  )  

ggsave(
  plot = plot,
  filename = paste0(out_path,time_stamp(),"plot_Violins_HALLMARK_ANDROGEN_RESPONSE_Clusters.pdf"),
  device = "pdf",
  width = 4,
  height = 6)

```

```{r Violin plot: targeted gene list}

genes <- c("AR", "SOX2", "AZGP1")

# --- Build a long data.frame with expression per cell & gene -------------------
expr_mtx <- as.matrix(logcounts(sce_obj)[genes,])
cell_md  <- as_tibble(colData(sce_obj)) %>%
  mutate(.cell = colnames(sce_obj))

expr_df <- as_tibble(t(expr_mtx), rownames = ".cell") %>%
  left_join(cell_md, by = ".cell") %>%
  pivot_longer(cols = all_of(genes), names_to = "Gene", values_to = "Expression")

# ensure cluster is a factor (and order by natural sort)
expr_df$louvain_pc20_k45_res0.6 <- factor(
  expr_df$louvain_pc20_k45_res0.6,
  levels = sort(unique(expr_df$louvain_pc20_k45_res0.6))
)

# --- Plot: facets stacked (one per gene), colored by cluster palette -----------
p <- ggplot(expr_df, aes(x = louvain_pc20_k45_res0.6, y = Expression, fill = louvain_pc20_k45_res0.6)) +
  geom_violin(scale = "width", alpha = 0.6, trim = TRUE) +
  geom_boxplot(width = 0.12, alpha = 0.6, outlier.shape = NA) +
  facet_grid(rows = vars(Gene)) +  # stacked facets (one on top of the other)
  scale_fill_manual(values = pal_clustering) +  # uses your cluster palette defined earlier
  labs(x = "Cluster (louvain_pc20_k45_res0.6)", y = "log-normalized expression", fill = "Cluster") +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    strip.text       = element_text(face = "bold", size = 12),
    axis.text.x      = element_text(angle = 45, hjust = 1, vjust = 1),
    legend.position  = "none"
  )

print(p)

# --- Optional: save to file ----------------------------------------------------
ggsave(
  plot = p,
  filename = paste0(out_path, time_stamp(), "facets_AR_SOX2_by_cluster.pdf"),
  device = "pdf",
  width = 5, height = 4
)


```


############################################################################
############################################################################

# Heatmaps — custom (literature) NE gene sets

```{r Z-score matrix}

plot_list = list()
plot_id = 1

for(signature_name in unique(custom_gene_sets_NE$term)){
  
  genes_on_Heatmap = custom_gene_sets_NE %>% 
    filter(term == signature_name) %>%
    pull(gene)
  
  # Find missing genes and try to find aliases
  ############################################
  
  missing_genes = setdiff(x = genes_on_Heatmap, y = rownames(sce_obj))
  allias = sapply(missing_genes, function(gene){check_aliase(sce = sce_obj, gene = gene)})
  
  if (length(allias)!=0){
    genes_on_Heatmap = c(genes_on_Heatmap, allias)
    genes_on_Heatmap = intersect(rownames(sce_obj), genes_on_Heatmap)
  }else{}
  
  # Finale gene list that will appear on the heatmap
  genes_on_Heatmap = unique(genes_on_Heatmap)
  
  # Reorder the object
  ###################
  
  # Example: sort by metadata column "cluster"
  ordered_indices <- order(sce_obj$louvain_pc20_k45_res0.6, sce_obj$Multiplexing_Condition )
  
  # Reorder columns (cells) of the SCE object
  sce_obj <- sce_obj[, ordered_indices]
  
  seurat_obj = as.Seurat(
    x = sce_obj, 
    counts = "counts", 
    data = "logcounts"
  )
  
  # Set the originalexp (aka "RNA" as the default assay)
  DefaultAssay(seurat_obj) = "originalexp"
  
  # Adds scale.data slot
  seurat_obj = ScaleData(seurat_obj)
  
  # Extract scaled data
  seurat_obj_signature_mtx <- GetAssayData(seurat_obj, assay = "originalexp", layer = "scale.data")[genes_on_Heatmap, ] %>% as.matrix() 
  
  # z-score heatnap
  ##################
  
  heatmap_anno = HeatmapAnnotation(
    Clusters = sce_obj$louvain_pc20_k45_res0.6,
    Condition = factor(sce_obj$Multiplexing_Condition, levels = unique(sce_obj$Multiplexing_Condition)), # Has to be a factor
    col = list(
      Condition = pal.treatment, 
      Clusters = pal_clustering)
  )
  
  
  row.fontsize <- ifelse(length(genes_on_Heatmap) >= 150, 4,
                         ifelse(length(genes_on_Heatmap) >= 100, 5, 
                                ifelse(length(genes_on_Heatmap) >= 50, 6,
                                       7)))
  
  
  plot = Heatmap(name = "Z-score",
                 top_annotation = heatmap_anno,
                 matrix = seurat_obj_signature_mtx,
                 cluster_rows = T,
                 cluster_columns = F,
                 cluster_column_slices = F,# If TRUE it will try to cluster cells
                 column_split = sce_obj$louvain_pc20_k45_res0.6,  # Will seperate clusters
                 show_column_dend = F, # If a dend has been provided in cluster_columns then it will use this one, otherwise, makes a new one.
                 show_column_names = F, # This will make cell names appear in this case (should remain F)
                 show_row_dend = F,
                 column_title_rot = 0,
                 use_raster = TRUE,
                 col_fun <- circlize::colorRamp2(
                   breaks = c(-3, 0, 3),  # ou plus symétrique : c(-3, 0, 3) selon la distribution
                   colors = c("darkblue", "white", "darkred")),
                 row_names_gp = grid::gpar(fontsize = row.fontsize),
                 width = unit(7, "inch"),  # reduce width for padding
                 height = unit(7, "inch"),  # reduce width for padding
                 heatmap_legend_param = list(
                   title = "z-score",
                   direction = "horizontal",
                   title_position = "topcenter",
                   legend_direction = "horizontal",
                   legend_width = unit(4, "cm")
                 )
  )
  
  plot_list[[signature_name]] = plot
  
  plot_id = plot_id + 1
  
}


##### 
# Draw the heatmap
#####

pdf(file = paste0(out_path, time_stamp(), "plot_Heatmap_Tang_signatures_clusters.pdf"),
    width = 12, height = 9.5)

for (signature_name in names(plot_list)) {
  
  draw(
    object = plot_list[[signature_name]],
    heatmap_legend_side = "bottom",
    annotation_legend_side = "left",
    column_title=signature_name,
    column_title_gp=grid::gpar(fontsize=16),
    merge_legend = F
  )
  
}

dev.off()

```

############################################################################
############################################################################

# Import DE table (for reference)

```{r Load DE table}

file_path = get_exp_file_path(
  organ = "Prostate" ,
  project = "Xenograft_Models",
  samples_ID = "P20-11_21d_ADT",
  prev_exp = "8_Differential_Expression",
  pattern = "DE_table_ADT_GSEA.csv")

DE_ADT = read.csv(file_path)

```

############################################################################
############################################################################

# Tang CRPC signature score matrix

```{r Tang CRPC signature score matrix}

md$louvain_pc20_k45_res0.6 = factor(md$louvain_pc20_k45_res0.6, levels = c(1,2,5,3,6,4))

Tang_score_mtx <- md %>%
  group_by(louvain_pc20_k45_res0.6) %>%
  summarise(across(contains("Tang"), mean)) %>%
  tibble::column_to_rownames("louvain_pc20_k45_res0.6")  # Makes the walktrap_75 cluster IDs row names

Tang_score_mtx <- as.matrix(Tang_score_mtx) 

plot = Heatmap(matrix = Tang_score_mtx,
               rect_gp = gpar(col = "white", lwd = 5),
               cluster_rows = F,
               column_names_rot = 45,
               cluster_columns = T,
               show_column_dend = FALSE,
               use_raster = TRUE,
               col_fun <- circlize::colorRamp2(
                 breaks = c(-0.5, 0, 0.25, 0.5),  # ou plus symétrique : c(-3, 0, 3) selon la distribution
                 colors = c("#F1F1F1", "#F1F1F1","#F6B62E", "#8B0020")),               width = unit(4, "inch"),  # reduce width for padding
               height = unit(4, "inch"),
               column_names_gp = grid::gpar(fontsize = 5),
               name = "Average signature score", 
               heatmap_legend_param = list(
                 direction = "horizontal",
                 title_position = "topcenter",
                 legend_direction = "horizontal",
                 legend_width = unit(4, "cm")
               )
)


pdf(file = paste0(out_path, time_stamp(), "plot_Heatmap_Tang_Signature.pdf"),
    width = 5, height = 6.5)

draw(
  object = plot,
  heatmap_legend_side = "bottom",
  annotation_legend_side = "bottom",
  column_title="Tang",
  column_title_gp=grid::gpar(fontsize=16),
  merge_legend = TRUE
)

dev.off()

```
